const _ = require("lodash")
const Joi = require("joi")
const querystring = require("querystring")
import axios from "axios"
import process from "process"
import { TransactionError } from "../util/errors"
import { defaultErrorHandler } from "../util/common"
import * as polyline from "polyline"

// HELP we're getting the models directly from dbschema. Is this valid?
const { db, models: m } = require("../core/dbschema")()

const DEFAULT_CROWDSTART_CAPACITY = 13
const DEFAULT_CROWDSTART_PRICE = 5.0
const DEFAULT_CROWDSTART_START = 30 // 30 days from now
const DEFAULT_CROWDSTART_VALIDITY = 15 // 15 days from now

/**
 * For the preview function we need a way of mocking the create process, without
 * actually creating the object.
 */
function _createMockCreate() {
  let id = -1000000
  let autogenId = () => {
    id += 1
    return id
  }

  function mockCreate(model, data, options) {
    return Promise.resolve(
      model.build(
        {
          ...data,
          id: autogenId(),
        },
        { isNewRecord: true, ...options }
      )
    )
  }

  return mockCreate
}

/**
 * Same scheme as the above, except this one actually creates the model in question
 * and returns the resulting instance
 */
function _createModelCreate(defaultOptions) {
  const modelCreate = (model, data, options) =>
    model.create(data, { ...defaultOptions, ...options })
  return modelCreate
}

async function fetchRoutingData(stops) {
  const path = stops.join("/")
  const [
    { data: busStops },
    { data: relatedRequests },
    { data: travelTimes },
    { data: paths },
  ] = await Promise.all([
    axios.get(`${process.env.ROUTING_SERVER_URL}/bus_stops/${path}`),
    axios.get(
      `${process.env.ROUTING_SERVER_URL}/path_requests/${path}?` +
        querystring.stringify({
          maxDistance: 400 /* Should match setting in autogenerated.vue */,
        })
    ),
    axios.get(`${process.env.ROUTING_SERVER_URL}/travel_times/${path}`),
    axios.get(`${process.env.ROUTING_SERVER_URL}/paths/${path}`),
  ])

  return { busStops, relatedRequests, travelTimes, paths }
}

export async function createCrowdstartRouteDetails(
  { stops, arrivalTime },
  { busStops, relatedRequests, travelTimes, paths },
  { createFunc, transaction }
) {
  const busStopsById = _.keyBy(busStops, x => x.index)
  const arrivalTimes = travelTimes
    .map(x => x)
    .reverse()
    .reduce(
      (acc, travelTime) => {
        acc.push(acc[acc.length - 1] - travelTime - 60000)
        return acc
      },
      [arrivalTime]
    )
    .reverse()

  // FIXME: For now, we assume that the alight stops and boarding stops
  // are split by the longest distance
  const [, dropOffIndex] = travelTimes.reduce(
    ([max, maxIndex], travelTime, index) => {
      if (travelTime > max) {
        return [travelTime, index + 1]
      } else {
        return [max, maxIndex]
      }
    },
    [travelTimes[0], 1]
  )

  // Find the nearest stops that matches routing.beeline.sg's database
  const bestMatch = await Promise.all(
    stops.map((stopIndex, index) => {
      const stop = busStopsById[stopIndex]
      return m.Stop.findAll(
        // distance less than 5m
        {
          where: [
            `ST_distance(
            ST_Transform(ST_SetSRID(stop.coordinates, 4326), 3414),
            ST_Transform(ST_GeomFromText('POINT(${stop.coordinates[0]} ${
              stop.coordinates[1]
            })', 4326), 3414)
          ) < 5`,
          ],
          order: [
            [
              db.literal(`ST_distance(
              ST_Transform(ST_SetSRID(stop.coordinates, 4326), 3414),
              ST_Transform(ST_GeomFromText('POINT(${stop.coordinates[0]} ${
                stop.coordinates[1]
              })', 4326), 3414)
            )`),
            ],
          ],
          transaction,
        }
      )
        .then(
          a =>
            a.length
              ? a[0]
              : createFunc(m.Stop, {
                  description: stop.description,
                  road: stop.roadName,
                  coordinates: {
                    type: "Point",
                    coordinates: stop.coordinates,
                  },
                })
        )
        .then(stopInstance => ({
          stop: stopInstance,
          arrivalTime: arrivalTimes[index],
        }))
    })
  )

  // Create the trip
  const dateOfTrip = new Date(Date.now() + 30 * 24 * 3600e3)
  const dateAtTime = msOfDay => {
    const d = new Date(
      dateOfTrip.getFullYear(),
      dateOfTrip.getMonth(),
      dateOfTrip.getDate(),
      0,
      0,
      0,
      msOfDay
    )
    return d
  }

  const route = await createFunc(m.Route, {
    name: `${bestMatch[0].stop.description} to ${
      bestMatch[bestMatch.length - 1].stop.description
    }`,
    from: bestMatch[0].stop.description,
    to: bestMatch[bestMatch.length - 1].stop.description,
    path: polyline.encode(_.flatten(paths).map(({ lat, lng }) => [lat, lng])),
    transportCompanyId: _.get(
      await m.TransportCompany.find({ where: { name: "Beeline" } }),
      "id",
      null
    ),
    label: "AUTO-" + Date.now(),
    schedule: "Mon - Fri",
    tags: ["crowdstart", "autogenerated", "tentative"],
    notes: {
      signage: "??",
      noPasses: 15,
      crowdstartExpiry: new Date(
        Date.now() + DEFAULT_CROWDSTART_VALIDITY * 24 * 3600e3
      ).toISOString(),
      tier: [{ pax: 15, price: DEFAULT_CROWDSTART_PRICE }],
    },
    features: `
- This route is currently **tentative**. Travel time, price and start date is
subject to change
- Expiry of the crowdstart may be extended if there are more people joining
the campaign.
    `,
  })

  const trip = await createFunc(
    m.Trip,
    {
      // One month from now
      date: new Date(Date.now() + DEFAULT_CROWDSTART_START * 24 * 3600e3),
      capacity: DEFAULT_CROWDSTART_CAPACITY,
      price: DEFAULT_CROWDSTART_PRICE * 10,
      status: null,
      bookingInfo: {
        windowType: "stop",
        windowSize: -5 * 60e3,
      },
      routeId: route.id,
      tripStops: bestMatch.map(({ stop, arrivalTime }, index) => ({
        stopId: stop.id,
        canBoard: index < dropOffIndex,
        canAlight: index >= dropOffIndex,
        time: dateAtTime(arrivalTime),
      })),
    },
    { include: [{ model: m.TripStop }] }
  )

  return { route, trip, stops: bestMatch.map(s => s.stop) }
}

export function register(server, options, next) {
  server.route({
    method: "POST",
    path: "/crowdstart/instant",
    config: {
      tags: ["api", "commuter"],
      validate: {
        payload: {
          stops: Joi.array().items(Joi.number().integer()),
          arrivalTime: Joi.number()
            .integer()
            .min(0)
            .max(24 * 60 * 60e3),
        },
      },
      auth: { access: { scope: ["user"] } },
      description: `
Creates a new Crowdstart route based on the stops specified in the payload.
The user must have a telephone number and a credit card saved.
      `,
    },
    async handler(request, reply) {
      // 1. Check whether user has a telephone number and a credit card.
      // 2. Fetch the stop data from routing.beeline.sg
      // 3. Find matching stops in `Stops` table
      // 4. Create the crowdstart route!
      async function ensureUserHasCreditCard(user) {
        TransactionError.assert(
          _.get(user, "savedPaymentInfo.sources.data.length", 0) >= 1,
          "You need to have at least one saved payment method to create a crowdstart route"
        )
      }

      async function createCrowdstartRouteAndBid({
        user,
        busStops,
        relatedRequests,
        travelTimes,
      }) {
        return db.transaction(async transaction => {
          const { route } = await createCrowdstartRouteDetails(
            {
              stops: request.payload.stops,
              arrivalTime: request.payload.arrivalTime,
            },
            { busStops, relatedRequests, travelTimes },
            {
              createFunc: _createModelCreate({ transaction }),
              transaction,
            }
          )

          return m.Bid.createForUserAndRoute(
            user,
            route,
            DEFAULT_CROWDSTART_PRICE,
            { transaction }
          )
        })
      }

      try {
        const user = await m.User.findById(request.auth.credentials.userId)

        await ensureUserHasCreditCard(user)
        const {
          busStops,
          relatedRequests,
          travelTimes,
          paths,
        } = await fetchRoutingData(request.payload.stops)

        TransactionError.assert(
          relatedRequests.length >= 15,
          `The total number of requests served by this crowdstart (${
            relatedRequests.length
          }) does not meet the minimum number required (15).`
        )

        const newBid = await createCrowdstartRouteAndBid({
          user,
          paths,
          busStops,
          relatedRequests,
          travelTimes,
        })

        reply({
          bid: newBid.toJSON(),
          route: (await m.Route.findById(newBid.routeId, {
            include: [
              {
                model: m.Trip,
                include: [{ model: m.TripStop, include: [m.Stop] }],
              },
            ],
          })).toJSON(),
        })
      } catch (err) {
        defaultErrorHandler(reply)(err)
      }
    },
  })

  server.route({
    method: "GET",
    path: "/crowdstart/preview_instant",
    config: {
      tags: ["api"],
      validate: {
        query: {
          stops: Joi.array().items(Joi.number().integer()),
          arrivalTime: Joi.number()
            .integer()
            .min(0)
            .max(24 * 60 * 60e3),
        },
      },
      description: `
Previews the crowdstart route that will be created with the given options
      `,
    },
    async handler(request, reply) {
      try {
        const {
          busStops,
          relatedRequests,
          travelTimes,
          paths,
        } = await fetchRoutingData(request.query.stops)

        const { route, trip, stops } = await createCrowdstartRouteDetails(
          {
            stops: request.query.stops,
            arrivalTime: request.query.arrivalTime,
          },
          { busStops, relatedRequests, travelTimes, paths },
          {
            createFunc: _createMockCreate(),
          }
        )

        reply({
          ...route.toJSON(),
          trips: [
            {
              ...trip.toJSON(),
              tripStops: trip.tripStops.map(ts => ({
                ...ts.toJSON(),
                stop: stops.find(s => s.id === ts.stopId).toJSON(),
              })),
            },
          ],
        })
      } catch (err) {
        defaultErrorHandler(reply)(err)
      }
    },
  })

  next()
}

register.attributes = {
  name: "endpoint-instant-crowdstart",
}
