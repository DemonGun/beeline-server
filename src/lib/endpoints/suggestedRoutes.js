import _ from "lodash"
import moment from "moment"
import Joi from "../util/joi"
import subzones from "@opengovsg/ura-subzones"
import {
  SecurityError,
  defaultErrorHandler,
  getModels,
  getDB,
} from "../util/common"
import { handleRequestWith, instToJSONOrNotFound } from "../util/endpoints"
import { TransactionError } from "../util/errors"
import { routeSchema } from "../models/SuggestedRoute"
import axios from "axios"
import * as polyline from "polyline"

const DEFAULT_CROWDSTART_PRICE = 5.0
const DEFAULT_CROWDSTART_VALIDITY = 30 // 30 days from now
const DEFAULT_CROWDSTART_START = 15 // 15 days from now
const DEFAULT_CROWDSTART_CAPACITY = 13

/**
 * Return schedule string from days object
 *
 * @param {object} days
 * @return {string}
 */
function stringDays(days) {
  let week = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"]
  return _.filter(week, d => days[d]).join(", ")
}

const ensureUserHasCreditCard = async function(user) {
  TransactionError.assert(
    _.get(user, "savedPaymentInfo.sources.data.length", 0) >= 1,
    "You need to have at least one saved payment method to create a crowdstart route"
  )
}

const buildCrowdstartRouteDetails = async function(
  suggestionInst,
  suggestedRouteInst,
  { m, transaction }
) {
  // FIXME: assuming the stops are sorted in route order
  const days = stringDays(suggestionInst.daysOfWeek)
  const suggestedRoute = suggestedRouteInst.route
  const from = suggestedRoute[0]
  const dropOffIndex = suggestedRoute.length - 1
  const to = suggestedRoute[dropOffIndex]

  const fromStop = subzones.getSubzoneAtPoint([from.lng, from.lat]).properties
    .niceName
  const toStop = subzones.getSubzoneAtPoint([to.lng, to.lat]).properties
    .niceName

  const decodedPaths = _.flatten(
    suggestedRoute.map(r => {
      if (!r.pathToNext) return []
      return polyline.decode(r.pathToNext)
    })
  )

  const date = moment()
    .add(DEFAULT_CROWDSTART_START, "d")
    .toDate()
  const dateAtTime = msOfDay => {
    return moment(date)
      .startOf("day")
      .add(msOfDay, "ms")
      .toDate()
  }

  const route = await m.Route.build(
    {
      name: `${fromStop} to ${toStop}`,
      from: fromStop,
      to: toStop,
      path: polyline.encode(decodedPaths),
      transportCompanyId: _.get(
        await m.TransportCompany.find({ where: { name: "Beeline" } }),
        "id",
        null
      ),
      label: "AC-" + suggestedRouteInst.id.toString().padStart(4, "0"),
      schedule: days,
      tags: ["crowdstart", "autogenerated", "tentative"],
      notes: {
        signage: "??",
        noPasses: 15,
        crowdstartExpiry: new Date(
          Date.now() + DEFAULT_CROWDSTART_VALIDITY * 24 * 3600e3
        ).toISOString(),
        tier: [{ pax: 15, price: DEFAULT_CROWDSTART_PRICE }],
      },
      features: `
- This route is currently **tentative**. Travel time, price and start date is
subject to change
- Expiry of the crowdstart may be extended if there are more people joining
the campaign.
    `,
      trips: [
        {
          date,
          capacity: DEFAULT_CROWDSTART_CAPACITY,
          price: DEFAULT_CROWDSTART_PRICE * 10,
          status: null,
          bookingInfo: {
            windowType: "stop",
            windowSize: -5 * 60e3,
          },
          tripStops: await Promise.all(
            suggestedRoute.map(async ({ stopId, time }, index) => ({
              stopId,
              canBoard: index < dropOffIndex,
              canAlight: index > 0,
              time: dateAtTime(time),
            }))
          ),
        },
      ],
    },
    {
      transaction,
      include: [{ model: m.Trip, include: [{ model: m.TripStop }] }],
    }
  )

  // Insert stop data seperately to prevent creating stops again when saving route
  for (let trip of route.trips) {
    for (let tripStop of trip.tripStops) {
      tripStop.setDataValue("stop", await m.Stop.findById(tripStop.stopId))
    }
  }

  return route
}

/**
 *
 * @param {*} server
 * @param {*} options
 * @param {*} next
 */
export function register(server, options, next) {
  /**
   * Ensures that the suggestion belongs to the user
   * @param {Suggestion} suggestion
   * @param {HAPI.Request} request
   * @param {object} param2
   * @return {Suggestion} instance
   */
  function authorizedToEdit(suggestion, request, { models }) {
    const isInstanceAuthorized = request.auth.credentials.scope === "superadmin"

    if (!isInstanceAuthorized) {
      throw new SecurityError("Only superadmins may modify suggested routes")
    }

    return suggestion
  }

  server.route({
    method: "GET",
    path: "/suggestions/{suggestionId}/suggested_routes",
    config: {
      tags: ["api"],
      validate: {
        params: {
          suggestionId: Joi.number().integer(),
        },
      },
    },
    handler: handleRequestWith(
      (ig, request, { models }) =>
        models.SuggestedRoute.findAll({
          where: {
            seedSuggestionId: request.params.suggestionId,
          },
          order: [["id", "DESC"]],
        }),
      suggestedRoutes => suggestedRoutes.map(s => s.toJSON())
    ),
  })

  server.route({
    method: "GET",
    path: "/suggestions/{suggestionId}/suggested_routes/{id}",
    config: {
      tags: ["api"],
      validate: {
        params: {
          suggestionId: Joi.number().integer(),
          id: Joi.number().integer(),
        },
      },
    },
    handler: handleRequestWith(
      (ig, request, { models }) =>
        models.SuggestedRoute.find({
          where: {
            id: request.params.id,
            seedSuggestionId: request.params.suggestionId,
          },
          order: [["id", "DESC"]],
        }),
      instToJSONOrNotFound
    ),
  })

  server.route({
    method: "DELETE",
    path: "/suggestions/{suggestionId}/suggested_routes/{id}",
    config: {
      tags: ["api"],
      validate: {
        params: {
          suggestionId: Joi.number().integer(),
          id: Joi.number().integer(),
        },
      },
      auth: { access: { scope: ["superadmin"] } },
    },
    handler: handleRequestWith(
      (ig, request, { models }) =>
        models.Suggestion.findById(request.params.suggestionId),
      authorizedToEdit,
      (ig, request, { models }) =>
        models.SuggestedRoute.destroy({
          where: {
            id: request.params.id,
            seedSuggestionId: request.params.suggestionId,
          },
          order: [["id", "DESC"]],
        }),
      () => ""
    ),
  })

  server.route({
    method: "POST",
    path: "/suggestions/{suggestionId}/suggested_routes",
    config: {
      tags: ["api"],
      validate: {
        params: {
          suggestionId: Joi.number().integer(),
        },
        payload: routeSchema,
      },
      description: `Create a new suggested route`,
      auth: { access: { scope: ["superadmin"] } },
    },
    handler: handleRequestWith(
      (ig, request, { models }) =>
        models.SuggestedRoute.create({
          route: request.payload,
          seedSuggestionId: request.params.suggestionId,
          userId: null /* Not created by a user */,
          adminEmail: request.auth.credentials.email,
        }),
      s => s.toJSON()
    ),
  })

  server.route({
    method: "GET",
    path: "/suggestions/{suggestionId}/suggested_routes/{id}/preview_route",
    config: {
      tags: ["api"],
      validate: {
        params: {
          suggestionId: Joi.number().integer(),
          id: Joi.number().integer(),
        },
      },
      description: `Builds a preview route from suggested route`,
      auth: { access: { scope: ["user"] } },
    },
    async handler(request, reply) {
      try {
        let m = getModels(request)

        // Get suggestion and suggested route
        const suggestionInst = await m.Suggestion.findById(
          request.params.suggestionId
        )
        const suggestedRouteInst = await m.SuggestedRoute.find({
          where: {
            id: request.params.id,
            seedSuggestionId: request.params.suggestionId,
          },
          order: [["id", "DESC"]],
        })

        const route = await buildCrowdstartRouteDetails(
          suggestionInst,
          suggestedRouteInst,
          {
            m,
          }
        )

        reply(route.toJSON())
      } catch (err) {
        defaultErrorHandler(reply)(err)
      }
    },
  })

  server.route({
    method: "POST",
    path:
      "/suggestions/{suggestionId}/suggested_routes/{id}/convert_to_crowdstart",
    config: {
      tags: ["api"],
      validate: {
        params: {
          suggestionId: Joi.number().integer(),
          id: Joi.number().integer(),
        },
      },
      description: `Create a new suggested routes`,
      auth: { access: { scope: ["user"] } },
    },
    async handler(request, reply) {
      /* eslint-disable require-jsdoc */
      async function createCrowdstartRouteAndBid(
        { m, db },
        { user, suggestionInst, suggestedRouteInst }
      ) {
        return db.transaction(async transaction => {
          // create crowdstart route details from suggested route
          // create route, trip and stops
          const route = await buildCrowdstartRouteDetails(
            suggestionInst,
            suggestedRouteInst,
            {
              m,
              transaction,
            }
          )

          await route.save()

          // create bid
          const bid = await m.Bid.createForUserAndRoute(
            user,
            route,
            DEFAULT_CROWDSTART_PRICE,
            { transaction }
          )
          return { route, bid }
        })
      }

      try {
        let m = getModels(request)
        let db = getDB(request)
        const user = await m.User.findById(request.auth.credentials.userId)

        // check user has credit card
        await ensureUserHasCreditCard(user)

        // Get suggestion and suggested route
        const suggestionInst = await m.Suggestion.findById(
          request.params.suggestionId
        )
        const suggestedRouteInst = await m.SuggestedRoute.find({
          where: {
            id: request.params.id,
            seedSuggestionId: request.params.suggestionId,
          },
          order: [["id", "DESC"]],
        })

        const { route, bid } = await createCrowdstartRouteAndBid(
          { m, db },
          { user, suggestionInst, suggestedRouteInst }
        )

        await suggestedRouteInst.update({ routeId: route.id })

        reply({
          bid: bid.toJSON(),
          route: route.toJSON(),
        })
      } catch (err) {
        defaultErrorHandler(reply)(err)
      }
    },
  })

  server.route({
    method: "POST",
    path:
      "/suggestions/{suggestionId}/suggested_routes/trigger_route_generation",
    config: {
      tags: ["api"],
      validate: {
        params: {
          suggestionId: Joi.number().integer(),
        },
        payload: {
          maxDetourMinutes: Joi.number(),
          startClusterRadius: Joi.number().integer(),
          startWalkingDistance: Joi.number().integer(),
          endClusterRadius: Joi.number().integer(),
          endWalkingDistance: Joi.number().integer(),
          timeAllowance: Joi.number().integer(),
          daysOfWeek: Joi.number().integer(),
          dataSource: Joi.string(),
        },
      },
      description: `Trigger Beeline Routing to generate a new route`,
      auth: { access: { scope: ["user"] } },
    },
    async handler(request, reply) {
      const response = await axios.post(
        `${process.env.ROUTING_SERVER_URL}/suggestions/${
          request.params.suggestionId
        }/update`,
        request.payload,
        { headers: { authorization: request.headers.authorization } }
      )

      // beeline-routing will return false on error and an array of the route on success
      reply(response.data).code(response.status)
    },
  })

  next()
}
register.attributes = {
  name: "endpoint-suggested-routes",
}
